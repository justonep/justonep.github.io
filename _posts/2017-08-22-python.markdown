---
layout: post
title: python内存机制
date: 2017-08-22 22:56:24.000000000 +09:00
---
我们创立三个列表
a=[]  //list1
b=[]  //list2
c=[a,b]  //list3

现象1:
>>> c[0] is a
True

结论1:a是list1的引用

现象2:
>>> c
[[], []]
>>> a.append(1)
>>> a
[1]
>>> c
[[1], []]

结论2:对于list里面的值 会随着引用指向的对象改变而改变


我大胆的推测 copy 和deepcopy 的区别和这个有很大关系

>>> d=c
>>> d
[[1], []]
>>> b.append(2)
>>> d
[[1], [2]]

上面创立了一个d引用c的对象 我们发现 b的改变会影响到c 

我们再看下copy，我们对c进行append操作，发现f并没有随之改变，证明copy操作重新复制了c指向的对象给予f

>>> c.append(5)
>>> c
[[1, 3], [2], 5]
>>> f
[[1, 3], [2]]

但是我发现下面的结果

>>> import copy
>>> f=copy.copy(c)
>>> f
[[1], [2]]
>>> a.append(3)
>>> f
[[1, 3], [2]]

我们对a进行操作的时候，f仍然会发生改变，我猜测是copy并没有对子list进行相同的复制操作


那么deepcopy 又发生了什么吗?

我们对a进行操作后发现，g没改
>>> g=copy.deepcopy(c)
>>> a.append(6)
>>> c
[[1, 3, 6], [2], 5]
>>> g
[[1, 3], [2], 5]

所以我认为 deepcopy对每个子list 每个引用都指向了一个复制的对象


所以copy只是对于顶层的引用对应的对象进行复制
而deepcopy对于每个引用对应的对象都进行了复制




